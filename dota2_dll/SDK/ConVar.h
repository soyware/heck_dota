#pragma once

//-----------------------------------------------------------------------------
// ConVar flags
//-----------------------------------------------------------------------------
// The default, no flags at all
#define FCVAR_NONE				0 

// Command to ConVars and ConCommands
// ConVar Systems
#define FCVAR_UNREGISTERED		(1<<0)	// If this is set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY	(1<<1)	// Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL			(1<<2)	// defined by the game DLL
#define FCVAR_CLIENTDLL			(1<<3)  // defined by the client DLL
#define FCVAR_HIDDEN			(1<<4)	// Hidden. Doesn't appear in find or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

// ConVar only
#define FCVAR_PROTECTED			(1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY			(1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define	FCVAR_ARCHIVE			(1<<7)	// set to cause it to be saved to vars.rc
#define	FCVAR_NOTIFY			(1<<8)	// notifies players when changed
#define	FCVAR_USERINFO			(1<<9)	// changes the client's info string

#define FCVAR_PRINTABLEONLY		(1<<10)  // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).

#define FCVAR_GAMEDLL_FOR_REMOTE_CLIENTS	(1<<10)  // When on concommands this allows remote clients to execute this cmd on the server. 
													 // We are changing the default behavior of concommands to disallow execution by remote clients without
													 // this flag due to the number existing concommands that can lag or crash the server when clients abuse them.

#define FCVAR_UNLOGGED			(1<<11)  // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING	(1<<12)  // never try to print that cvar

// It's a ConVar that's shared between the client and the server.
// At signon, the values of all such ConVars are sent from the server to the client (skipped for local
//  client, of course )
// If a change is requested it must come from the console (i.e., no remote client changes)
// If a value is changed while a server is active, it's replicated to all connected clients
#define FCVAR_REPLICATED		(1<<13)	// server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_CHEAT				(1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS				(1<<15) // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
#define FCVAR_DEMO				(1<<16) // record this cvar when starting a demo file
#define FCVAR_DONTRECORD		(1<<17) // don't record these command in demofiles
#define FCVAR_SS_ADDED			(1<<18) // This is one of the "added" FCVAR_SS variables for the splitscreen players
#define FCVAR_RELEASE			(1<<19) // Cvars tagged with this are the only cvars avaliable to customers
#define FCVAR_RELOAD_MATERIALS	(1<<20)	// If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES	(1<<21)	// If this cvar changes, if forces a texture reload

#define FCVAR_NOT_CONNECTED		(1<<22)	// cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD (1<<23)	// Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_GAMECONSOLE	(1<<24) // cvar written to config.cfg on the Xbox

#define FCVAR_SERVER_CAN_EXECUTE	(1<<28)// the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY	(1<<29)// If this is set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE	(1<<30)	// IVEngineClient::ClientCmd is allowed to execute this command. 
											// Note: IVEngineClient::ClientCmd_Unrestricted can run any client command.

#define FCVAR_ACCESSIBLE_FROM_THREADS	(1<<25)	// used as a debugging tool necessary to check material system thread convars
// #define FCVAR_AVAILABLE			(1<<26)
// #define FCVAR_AVAILABLE			(1<<27)
// #define FCVAR_AVAILABLE			(1<<31)

#define FCVAR_MATERIAL_THREAD_MASK ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD )	

class ConCommandBase
{
public:
	void*			vt;
	ConCommandBase* m_pNext;
	bool			m_bRegistered;
	const char*		m_pszName;
	const char*		m_pszHelpString;
	int				m_nFlags;

	~ConCommandBase()
	{
		I::Cvar->UnregisterConCommand(this);
	}

	inline void Create(const char* pName, const char* pHelpString = nullptr, int flags = 0)
	{
		typedef void(__thiscall* Fn)(ConCommandBase*, const char*, const char*, int);
		GetVF<Fn>(this, 11)(this, pName, pHelpString, flags);
	}
};

#pragma region CCommand

enum cmd_source_t
{
	// Added to the console buffer by gameplay code.  Generally unrestricted.
	kCommandSrcCode,

	// Sent from code via engine->ClientCmd, which is restricted to commands visible
	// via FCVAR_CLIENTCMD_CAN_EXECUTE.
	kCommandSrcClientCmd,

	// Typed in at the console or via a user key-bind.  Generally unrestricted, although
	// the client will throttle commands sent to the server this way to 16 per second.
	kCommandSrcUserInput,

	// Came in over a net connection as a clc_stringcmd
	// host_client will be valid during this state.
	//
	// Restricted to FCVAR_GAMEDLL commands (but not convars) and special non-ConCommand
	// server commands hardcoded into gameplay code (e.g. "joingame")
	kCommandSrcNetClient,

	// Received from the server as the client
	//
	// Restricted to commands with FCVAR_SERVER_CAN_EXECUTE
	kCommandSrcNetServer,

	// Being played back from a demo file
	//
	// Not currently restricted by convar flag, but some commands manually ignore calls
	// from this source.  FIXME: Should be heavily restricted as demo commands can come
	// from untrusted sources.
	kCommandSrcDemoFile,

	// Invalid value used when cleared
	kCommandSrcInvalid = -1
};

//struct characterset_t
//{
//	char set[256];
//};
//
//void CharacterSetBuild(characterset_t *pSetBuffer, const char *pszSetString)
//{
//	// Test our pointers
//	if (!pSetBuffer || !pszSetString)
//		return;
//
//	memset(pSetBuffer->set, 0, sizeof(pSetBuffer->set));
//
//	for (unsigned int i = 0; pszSetString[i]; ++i)
//		pSetBuffer->set[pszSetString[i]] = 1;
//}
//
//static characterset_t s_BreakSet;
//static bool s_bBuiltBreakSet = false;

class CCommand
{
public:
	CCommand()
	{
		//if (!s_bBuiltBreakSet)
		//{
		//	s_bBuiltBreakSet = true;
		//	CharacterSetBuild(&s_BreakSet, "{}()':");
		//}

		Reset();
	}

	CCommand(int nArgC, const char** ppArgV, cmd_source_t source)
	{
		// assert(nArgC > 0);

		//if (!s_bBuiltBreakSet)
		//{
		//	s_bBuiltBreakSet = true;
		//	CharacterSetBuild(&s_BreakSet, "{}()':");
		//}

		Reset();

		char* pBuf = m_pArgvBuffer;
		char* pSBuf = m_pArgSBuffer;
		m_nArgc = nArgC;
		for (int i = 0; i < nArgC; ++i)
		{
			m_ppArgv[i] = pBuf;

			size_t nLen = strlen(ppArgV[i]);
			memcpy(pBuf, ppArgV[i], nLen + 1);

			if (i == 0)
				m_nArgv0Size = nLen;

			pBuf += nLen + 1;

			bool bContainsSpace = strchr(ppArgV[i], ' ') != NULL;
			if (bContainsSpace)
				*pSBuf++ = '\"';

			memcpy(pSBuf, ppArgV[i], nLen);
			pSBuf += nLen;

			if (bContainsSpace)
				*pSBuf++ = '\"';

			if (i != nArgC - 1)
				*pSBuf++ = ' ';
		}

		m_source = source;
	}

	void Reset()
	{
		m_nArgc = 0;
		m_nArgv0Size = 0;
		m_pArgSBuffer[0] = 0;
		m_source = kCommandSrcInvalid;
	}

	int ArgC() const { return m_nArgc; }
	const char** ArgV() const { return m_nArgc ? (const char**)m_ppArgv : nullptr; }
	const char* ArgS() const { return m_nArgv0Size ? &m_pArgSBuffer[m_nArgv0Size] : ""; }	// All args that occur after the 0th arg, in string form
	const char* GetCommandString() const { return m_nArgc ? m_pArgSBuffer : ""; }	// The entire command in string form, including the 0th arg
	const char* operator[](int nIndex) const { return Arg(nIndex); }	// Gets at arguments
	const char* Arg(int nIndex) const		// Gets at arguments
	{
		// FIXME: Many command handlers appear to not be particularly careful
		// about checking for valid argc range. For now, we're going to
		// do the extra check and return an empty string if it's out of range
		if (nIndex < 0 || nIndex >= m_nArgc)
			return "";
		return m_ppArgv[nIndex];
	}
	inline cmd_source_t Source() const { return m_source; }

	// Helper functions to parse arguments to commands.
	const char* FindArg(const char* pName) const
	{
		int nArgC = ArgC();
		for (int i = 1; i < nArgC; i++)
		{
			if (!_stricmp(Arg(i), pName))
				return (i + 1) < nArgC ? Arg(i + 1) : "";
		}
		return 0;
	}

	int FindArgInt(const char* pName, int nDefaultVal) const
	{
		const char* pVal = FindArg(pName);
		if (pVal)
			return atoi(pVal);
		else
			return nDefaultVal;
	}


	static int MaxCommandLength() { return COMMAND_MAX_LENGTH - 1; }
	//static characterset_t* DefaultBreakSet() { return &s_BreakSet; }

private:
	enum
	{
		COMMAND_MAX_ARGC = 64,
		COMMAND_MAX_LENGTH = 512,
	};

	int			m_nArgc;
	int			m_nArgv0Size;
	char		m_pArgSBuffer[COMMAND_MAX_LENGTH];
	char		m_pArgvBuffer[COMMAND_MAX_LENGTH];
	const char* m_ppArgv[COMMAND_MAX_ARGC];
	cmd_source_t m_source;
};

#pragma endregion

#pragma region ConCommand

//-----------------------------------------------------------------------------
// Called when a ConCommand needs to execute
//-----------------------------------------------------------------------------
typedef void (*FnCommandCallbackV1_t)(void);
typedef void (*FnCommandCallback_t)(const CCommand& command);

#define COMMAND_COMPLETION_MAXITEMS		64
#define COMMAND_COMPLETION_ITEM_LENGTH	64

//-----------------------------------------------------------------------------
// Returns 0 to COMMAND_COMPLETION_MAXITEMS worth of completion strings
//-----------------------------------------------------------------------------
typedef int (*FnCommandCompletionCallback)(const char* partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH]);

class CCommandContext;

//-----------------------------------------------------------------------------
// Interface version
//-----------------------------------------------------------------------------
class ICommandCallback
{
public:
	virtual void CommandCallback(const CCommandContext& context, const CCommand& command) = 0;
};

class ICommandCompletionCallback
{
public:
	virtual int  CommandCompletionCallback(const char* pPartial, CUtlVector< CUtlString >& commands) = 0;
};

int DefaultCompletionFunc(const char* partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH])
{
	return 0;
}

class ConCommand : public ConCommandBase
{
public:
	//void Create(const char* pName, FnCommandCallbackV1_t pCallback,
	//	const char* pHelpString = nullptr, int flags = 0, FnCommandCompletionCallback pCompletionCallback = nullptr)
	//{
	//	m_CommandCallbacks.AddToTail(pCallback);
	//	m_bUsingNewCommandCallback = false;
	//	m_bUsingCommandCallbackInterface = false;
	//	m_fnCompletionCallback = pCompletionCallback ? pCompletionCallback : DefaultCompletionFunc;
	//	m_bHasCompletionCallback = pCompletionCallback != nullptr;

	//	ConCommandBase::Create(pName, pHelpString, flags);
	//}

	//void Create(const char* pName, FnCommandCallback_t pCallback,
	//	const char* pHelpString = nullptr, int flags = 0, FnCommandCompletionCallback pCompletionCallback = nullptr)
	//{
	//	m_CommandCallbacks.AddToTail(pCallback);
	//	m_bUsingNewCommandCallback = true;
	//	m_bUsingCommandCallbackInterface = false;
	//	m_fnCompletionCallback = pCompletionCallback ? pCompletionCallback : DefaultCompletionFunc;
	//	m_bHasCompletionCallback = pCompletionCallback != nullptr;

	//	ConCommandBase::Create(pName, pHelpString, flags);
	//}

	//void Create(const char* pName, ICommandCallback* pCallback,
	//	const char* pHelpString = nullptr, int flags = 0, ICommandCompletionCallback* pCompletionCallback = nullptr)
	//{
	//	m_CommandCallbacks.AddToTail(pCallback);
	//	m_bUsingNewCommandCallback = false;
	//	m_pCommandCompletionCallback = pCompletionCallback;
	//	m_bHasCompletionCallback = pCompletionCallback != nullptr;
	//	m_bUsingCommandCallbackInterface = true;

	//	ConCommandBase::Create(pName, pHelpString, flags);
	//}

	//void Dispatch(const CCommandContext& context, const CCommand& command)
	//{
	//	auto& callbacks = m_pParent->m_CommandCallbacks;

	//	for (int i = 0; i < callbacks.Count(); ++i)
	//	{
	//		if (m_pParent->m_bUsingNewCommandCallback)
	//		{
	//			(*reinterpret_cast<FnCommandCallback_t*>(callbacks[i]))(command);
	//		}
	//		else if (m_pParent->m_bUsingCommandCallbackInterface)
	//		{
	//			reinterpret_cast<ICommandCallback*>(callbacks[i])->CommandCallback(context, command);
	//		}
	//		else
	//		{
	//			(*reinterpret_cast<FnCommandCallbackV1_t*>(callbacks[i]))();
	//		}
	//	}
	//}

	inline void Dispatch(const CCommandContext& context, const CCommand& command)
	{
		typedef void(__thiscall* Fn) (ConCommand*, const CCommandContext&, const CCommand&);
		GetVF<Fn>(this, 15)(this, context, command);
	}

	union
	{
		FnCommandCompletionCallback	m_fnCompletionCallback;
		ICommandCompletionCallback* m_pCommandCompletionCallback;
	};

	bool m_bHasCompletionCallback : 1;
	bool m_bUsingNewCommandCallback : 1;
	bool m_bUsingCommandCallbackInterface : 1;

	struct CallbackInfo_t
	{
		void* callback;
		uint8_t flags;
	};

	CUtlVector<CallbackInfo_t> m_CommandCallbacks;

	ConCommand* m_pParent;
};

template< class T >
class CConCommandMemberAccessor : public ConCommand/*, public ICommandCallback, public ICommandCompletionCallback*/
{
	typedef void (T::* FnMemberCommandCallback_t)(const CCommand& command);
	typedef int  (T::* FnMemberCommandCompletionCallback_t)(const char* pPartial, CUtlVector< CUtlString >& commands);

public:
	void*	vt;
	void*	vt2;
	T*		m_pOwner;
	FnMemberCommandCallback_t m_Func;
	FnMemberCommandCompletionCallback_t m_CompletionFunc;
};

#pragma endregion

typedef void (*FnChangeCallback_t)(/*IConVar*/void* var, const char* pOldValue, float flOldValue);

std::vector<ConVar*> g_CreatedConVars;

class ConVar : public ConCommandBase
{
public:
	void*		vt;
	ConVar*		m_pParent;
	const char*	m_pszDefaultValue;

	char*		m_pszString;
	int			m_StringLength;
	float		m_fValue;
	int			m_nValue;

	int			unk;

	float		m_fMinVal;
	float		m_fMaxVal;
	bool		m_bHasMin;
	bool		m_bHasMax;

	CUtlVector<FnChangeCallback_t> m_fnChangeCallbacks;

	~ConVar()
	{
		I::MemAlloc->Free(m_pszString);
	}

	inline float GetFloat()
	{
		return m_fValue;
	}

	inline int GetInt()
	{
		return m_nValue;
	}

	inline const char* GetString()
	{
		return m_pszString;
	}

	inline void SetValue(const char* value)
	{
		typedef void(__thiscall* Fn) (void*, const char*);
		GetVF<Fn>(this, 16)(this, value);
	}

	inline void SetValue(float value)
	{
		typedef void(__thiscall* Fn) (void*, float);
		GetVF<Fn>(this, 17)(this, value);
	}

	inline void SetValue(int value)
	{
		typedef void(__thiscall* Fn) (void*, int);
		GetVF<Fn>(this, 18)(this, value);
	}

	inline void SetValue(Color value)
	{
		typedef void(__thiscall* Fn) (void*, Color);
		GetVF<Fn>(this, 19)(this, value);
	}

	bool SetColorFromString(const char* value)
	{
		int n[4];
		int c = sscanf_s(value, "%i %i %i %i", &(n[0]), &(n[1]), &(n[2]), &(n[3]));
		if (c < 3)
			return false;

		if (c == 3)
			n[3] = 255;

		if (n[0] > 0xFF || n[1] > 0xFF || n[2] > 0xFF || n[3] > 0xFF)
			return false;

		reinterpret_cast<uint8_t*>(&m_nValue)[0] = static_cast<uint8_t>(n[0]);
		reinterpret_cast<uint8_t*>(&m_nValue)[1] = static_cast<uint8_t>(n[1]);
		reinterpret_cast<uint8_t*>(&m_nValue)[2] = static_cast<uint8_t>(n[2]);
		reinterpret_cast<uint8_t*>(&m_nValue)[3] = static_cast<uint8_t>(n[3]);

		m_fValue = static_cast<float>(m_nValue);

		return true;
	}

	void Create(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString, 
		bool bMin = false, float fMin = 0.f, bool bMax = false, float fMax = 0.f, 
		FnChangeCallback_t callback = nullptr)
	{
		static const ConVar* cv = I::Cvar->FindVar("sensitivity");
		ConCommandBase::vt = cv->ConCommandBase::vt;
		ConVar::vt = cv->ConVar::vt;

		m_pParent = this;

		static const char* emptyString = "";
		m_pszDefaultValue = pDefaultValue ? pDefaultValue : emptyString;

		m_StringLength = static_cast<int>(strlen(m_pszDefaultValue)) + 1;
		m_pszString = static_cast<char*>(I::MemAlloc->Alloc(m_StringLength));
		memmove(m_pszString, m_pszDefaultValue, m_StringLength);

		unk = 0;

		m_bHasMin = bMin;
		m_fMinVal = fMin;

		m_bHasMax = bMax;
		m_fMaxVal = fMax;

		if (!SetColorFromString(m_pszString))
		{
			float fval = static_cast<float>(atof(m_pszString));
			m_fValue = fval;
			if (isinf(fval))
			{
				Log::Msg("ConVar(%s) defined with infinite float value (%s)\n", pName);
				m_fValue = FLT_MAX;
			}
			m_nValue = atoi(m_pszString);
		}

		if (callback)
			m_fnChangeCallbacks.AddToTail(callback);

		ConCommandBase::Create(pName, pHelpString, flags);

		g_CreatedConVars.push_back(this);
	}
};